<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Velocity-Based Training Tracker</title>

    <!-- React / Tailwind / Chart.js / Socket.io -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Slight Tailwind config (optional tweaks) -->
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              gymRed: '#4a0008', // deep maroon
              gymRedMid: '#6b0b12',
              gymGold: '#caa23a',
              gymGoldBright: '#f3d36b',
              mutedGray: '#6e6e6e',
              lightBlue: '#5fa8ff',
            }
          }
        }
      }
    </script>

    <style>
      /* small custom tweaks */
      body { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
      /* make canvas crisp on HiDPI */
      canvas { image-rendering: -webkit-optimize-contrast; }
    </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function VelocityTracker() {
      const [loadPercent, setLoadPercent] = useState(80);
      const [isRecording, setIsRecording] = useState(false);
      const [status, setStatus] = useState('Ready');
      const [repCount, setRepCount] = useState(0);
      const [results, setResults] = useState(null);

      const socketRef = useRef(null);
      const liveChartRef = useRef(null);
      const summaryChartRef = useRef(null);
      const liveCanvasRef = useRef(null);
      const summaryCanvasRef = useRef(null);

      const liveDataRef = useRef({
        t: [],
        vx: [],
        vy: [],
        vz: [],
        vt: [],
        vtConc: []
      });

      // Initialize charts + socket
      useEffect(() => {
        // Live chart
        const liveCtx = liveCanvasRef.current.getContext('2d');
        liveChartRef.current = new Chart(liveCtx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              { label: 'vx', data: [], borderColor: '#6e6e6e', borderWidth: 1, pointRadius: 0, tension: 0.15 },
              { label: 'vy', data: [], borderColor: '#6e6e6e', borderWidth: 1, pointRadius: 0, tension: 0.15 },
              { label: 'vz', data: [], borderColor: '#5fa8ff', borderWidth: 2, pointRadius: 0, tension: 0.2 },
              { label: 'vt', data: [], borderColor: '#ffffff', borderWidth: 2, pointRadius: 0, tension: 0.2 },
              // concentric vt - only present during concentric windows, null otherwise => no connecting lines
              { label: 'concentric', data: [], borderColor: '#d14b4b', borderWidth: 2, pointRadius: 0, tension: 0.1, spanGaps: false }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            interaction: { mode: 'index', intersect: false },
            plugins: {
              legend: {
                labels: { color: '#e6e6e6' },
                position: 'top'
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    if (context.dataset.label === 'concentric' && (context.raw === null || context.raw === undefined)) {
                      return null;
                    }
                    return `${context.dataset.label}: ${context.formattedValue}`;
                  }
                }
              }
            },
            scales: {
              x: {
                title: { display: true, text: 'Time (s)', color: '#f3d36b' },
                ticks: { color: '#d1c29a' },
                grid: { color: 'rgba(200,150,80,0.06)' }
              },
              y: {
                title: { display: true, text: 'Velocity (m/s)', color: '#f3d36b' },
                ticks: { color: '#d1c29a' },
                grid: { color: 'rgba(200,150,80,0.06)' }
              }
            }
          }
        });

        // Connect to socket.io
        try {
          const socket = io('http://localhost:5000');
          socketRef.current = socket;

          socket.on('status', (data) => {
            if (data && data.message) setStatus(data.message);
          });

          socket.on('rep_detected', (data) => {
            if (data && typeof data.rep_count !== 'undefined') {
              setRepCount(data.rep_count);
            }
          });

          socket.on('live_data', (data) => {
            // defensive checks
            if (!data) return;
            const liveData = liveDataRef.current;

            // Append timestamps and velocities
            // expect data fields: t, vx, vy, vz, vt, vt_conc (vt_conc may be null)
            liveData.t.push(Number(data.t));
            liveData.vx.push(Number(data.vx));
            liveData.vy.push(Number(data.vy));
            liveData.vz.push(Number(data.vz));
            liveData.vt.push(Number(data.vt));
            // IMPORTANT: use null for non-concentric points to break lines
            const concVal = (typeof data.vt_conc !== 'undefined' && data.vt_conc !== null) ? Number(data.vt_conc) : null;
            liveData.vtConc.push(concVal);

            // limit buffer
            const maxPoints = 500;
            if (liveData.t.length > maxPoints) {
              liveData.t.shift();
              liveData.vx.shift();
              liveData.vy.shift();
              liveData.vz.shift();
              liveData.vt.shift();
              liveData.vtConc.shift();
            }

            // push into chart
            const chart = liveChartRef.current;
            chart.data.labels = liveData.t.map(t => t.toFixed(2));
            chart.data.datasets[0].data = liveData.vx;
            chart.data.datasets[1].data = liveData.vy;
            chart.data.datasets[2].data = liveData.vz;
            chart.data.datasets[3].data = liveData.vt;
            // vtConc may contain nulls — Chart.js will break line when value is null (spanGaps: false)
            chart.data.datasets[4].data = liveData.vtConc;
            chart.update('none');
          });

          socket.on('results', (data) => {
            setResults(data);
            setIsRecording(false);
            setStatus('Complete');
            // update summary chart after small defer so DOM exists
            setTimeout(() => updateSummaryChart(data), 50);
          });

          socket.on('error', (err) => {
            setStatus(err && err.message ? `Error: ${err.message}` : 'Error');
            setIsRecording(false);
          });
        } catch (e) {
          console.warn('Socket init failed', e);
        }

        return () => {
          // cleanup
          if (socketRef.current) socketRef.current.disconnect();
          if (liveChartRef.current) liveChartRef.current.destroy();
          if (summaryChartRef.current) summaryChartRef.current.destroy();
        };
      }, []);

      // Summary chart builder
      const updateSummaryChart = (data) => {
        if (!data) return;
        const ctx = summaryCanvasRef.current.getContext('2d');
        if (summaryChartRef.current) summaryChartRef.current.destroy();

        const repNumbers = (data.avg_velocity || []).map((_, idx) => idx + 1);

        summaryChartRef.current = new Chart(ctx, {
          type: 'line',
          data: {
            labels: repNumbers,
            datasets: [
              {
                label: 'Mean Velocity',
                data: data.avg_velocity || [],
                borderColor: '#ffffff',
                backgroundColor: '#ffffff',
                borderWidth: 2,
                pointRadius: 4,
                tension: 0.2
              },
              {
                label: 'Peak Velocity',
                data: data.peak_velocity || [],
                borderColor: '#d14b4b',
                backgroundColor: '#d14b4b',
                borderWidth: 2,
                pointRadius: 4,
                tension: 0.2
              },
              ...(data.trend_line && data.trend_line.length > 0 ? [{
                label: 'Peak Trend',
                data: data.trend_line,
                borderColor: '#caa23a',
                borderWidth: 2,
                borderDash: [6, 4],
                pointRadius: 0,
                tension: 0.15
              }] : [])
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { labels: { color: '#e6e6e6' } }
            },
            scales: {
              x: { ticks: { color: '#d1c29a' }, title: { display: true, text: 'Rep #', color: '#f3d36b' } },
              y: { ticks: { color: '#d1c29a' }, title: { display: true, text: 'Velocity (m/s)', color: '#f3d36b' } }
            }
          }
        });
      };

      // control actions
      const startRecording = async () => {
        setIsRecording(true);
        setRepCount(0);
        setResults(null);
        setStatus('Starting...');
        liveDataRef.current = { t: [], vx: [], vy: [], vz: [], vt: [], vtConc: [] };

        try {
          await fetch('http://localhost:5000/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ load_percent: loadPercent })
          });
        } catch (error) {
          setStatus(`Error: ${error.message}`);
          setIsRecording(false);
        }
      };

      const stopRecording = async () => {
        try {
          await fetch('http://localhost:5000/stop', { method: 'POST' });
          setIsRecording(false);
        } catch (error) {
          console.error('Error stopping:', error);
        }
      };

      // simple AI coach insight generation
      const renderAIInsight = (res) => {
        if (!res) return 'No data yet — finish a set for tailored feedback.';
        const rir = Number(res.predicted_rir);
        if (isNaN(rir)) return 'No RIR available.';
        if (rir >= 4) return 'You have plenty left in reserve — consider increasing load next set for progressive overload.';
        if (rir >= 2) return 'Good working range — maintain load and focus on bar speed and technique.';
        if (rir >= 1) return 'Approaching technical failure — focus on tight form and stop after next quality rep.';
        return 'At or below 0 RIR — you are at failure. Rest and reset form before next set.';
      };

      // small formatted stat helper
      const fmt = (v) => (typeof v === 'number' ? (Math.round(v * 100) / 100) : v);

      return (
        <div className="min-h-screen p-8" style={{ background: 'linear-gradient(180deg, #3b0000 0%, #000000 50%, #6b4b10 100%)', color: '#fff' }}>
          <div className="max-w-7xl mx-auto">
            {/* Header */}
            <div className="mb-8 text-center">
              <div className="flex items-center justify-center gap-3 mb-2">
                <svg className="w-10 h-10" viewBox="0 0 24 24" fill="none">
                  <circle cx="12" cy="12" r="10" stroke="#caa23a" strokeWidth="1.5" />
                  <path d="M13 10V3L4 14h7v7l9-11h-7z" stroke="#f3d36b" strokeWidth="1.4" strokeLinecap="round" strokeLinejoin="round" />
                </svg>
                <h1 className="text-4xl font-bold tracking-tight">Velocity-Based Training Tracker</h1>
              </div>
              <p className="text-gymGoldBright/80">Real-time rep analysis • RIR prediction • AI Coach insights</p>
            </div>

            {/* Control Panel */}
            <div className="bg-black/40 rounded-xl p-6 mb-6 border border-[#3a0b0b]">
              <div className="flex items-center gap-6 flex-wrap">
                <div className="flex-1 min-w-[200px]">
                  <label className="block text-sm font-medium mb-2 text-[#f3d36b]">Load Percentage</label>
                  <input
                    type="number"
                    value={loadPercent}
                    onChange={(e) => setLoadPercent(parseFloat(e.target.value))}
                    disabled={isRecording}
                    className="w-full px-4 py-2 bg-[#120606] rounded-lg border border-[#2b0f0f] focus:border-gymGold focus:outline-none disabled:opacity-50 text-white"
                    min="0"
                    max="100"
                    step="0.1"
                  />
                </div>

                <div className="flex gap-3">
                  <button
                    onClick={startRecording}
                    disabled={isRecording}
                    className="flex items-center gap-2 px-6 py-3 bg-[#8b0f12] hover:bg-[#900f10] disabled:bg-slate-700 disabled:cursor-not-allowed rounded-lg font-semibold transition-colors"
                  >
                    <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                      <path d="M8 5v14l11-7z"/>
                    </svg>
                    Start
                  </button>
                  <button
                    onClick={stopRecording}
                    disabled={!isRecording}
                    className="flex items-center gap-2 px-6 py-3 bg-[#4b0b0c] hover:bg-[#6b0b0c] disabled:bg-slate-700 disabled:cursor-not-allowed rounded-lg font-semibold transition-colors"
                  >
                    <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                      <rect x="6" y="6" width="12" height="12"/>
                    </svg>
                    Stop
                  </button>
                </div>
              </div>

              <div className="mt-4 flex items-center gap-6">
                <div className="flex items-center gap-2">
                  <div className={`w-3 h-3 rounded-full ${isRecording ? 'bg-red-500 animate-pulse' : 'bg-slate-600'}`}></div>
                  <span className="text-sm">{status}</span>
                </div>
                <div className="text-sm font-semibold" style={{ color: '#f3d36b' }}>
                  Reps Detected: <span className="text-2xl text-white">{repCount}</span>
                </div>
              </div>
            </div>

            {/* Live Velocity Chart */}
            <div className="bg-black/35 rounded-xl p-6 mb-6 border border-[#2b0b0b]">
              <h2 className="text-xl font-semibold mb-4 flex items-center gap-2" style={{ color: '#f3d36b' }}>
                <svg className="w-5 h-5" viewBox="0 0 24 24" fill="none">
                  <path d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" stroke="#f3d36b" strokeWidth="1.6" strokeLinecap="round" strokeLinejoin="round"></path>
                </svg>
                Real-Time Velocity
              </h2>
              <div style={{ height: '400px' }} className="rounded-md overflow-hidden">
                <canvas ref={liveCanvasRef}></canvas>
              </div>
            </div>

            {/* Results: Stats + AI Tile */}
            {results && (
              <div className="space-y-6">
                {/* Stats Cards */}
                <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                  <div className="bg-[#0f0b0b] rounded-xl p-6 border border-[#2a1a1a]">
                    <div className="text-sm text-[#d1c29a] mb-1">Reps Completed</div>
                    <div className="text-3xl font-bold">{fmt(results.reps_completed)}</div>
                  </div>

                  <div className="bg-[#0f0b0b] rounded-xl p-6 border border-[#2a1a1a]">
                    <div className="text-sm text-[#d1c29a] mb-1">Velocity Loss</div>
                    <div className="text-3xl font-bold">{fmt(results.velocity_loss)}%</div>
                  </div>

                  <div className="bg-[#0f0b0b] rounded-xl p-6 border border-[#2a1a1a]">
                    <div className="text-sm text-[#d1c29a] mb-1">Mean Velocity (Last Rep)</div>
                    <div className="text-3xl font-bold">{fmt(results.mean_velocity_last_rep)}</div>
                  </div>

                  {/* Emphasized RIR tile */}
                  <div className="bg-[#0b0806] rounded-xl p-6 border-2 border-[#caa23a] shadow-[0_10px_30px_rgba(202,162,58,0.08)]">
                    <div className="text-sm text-[#f3d36b] mb-1">Estimated RIR</div>
                    <div className="text-3xl font-bold" style={{ color: '#fff' }}>{fmt(results.predicted_rir)}</div>
                  </div>
                </div>

                {/* AI Coach Insight */}
                <div className="bg-[#0f0b0b] rounded-xl p-6 border border-[#3d2a12]">
                  <div className="flex items-center justify-between">
                    <div>
                      <div className="text-sm text-[#f3d36b] mb-1">AI Coach Insight</div>
                      <div className="text-lg text-white max-w-3xl">
                        {renderAIInsight(results)}
                      </div>
                    </div>
                    <div className="text-sm text-[#d1c29a]">Confidence: <span className="font-semibold">medium</span></div>
                  </div>
                </div>

                {/* Rep Summary Chart */}
                <div className="bg-black/35 rounded-xl p-6 border border-[#2b0b0b]">
                  <h2 className="text-xl font-semibold mb-4" style={{ color: '#f3d36b' }}>Rep Velocity Analysis</h2>
                  <div style={{ height: '400px' }}>
                    <canvas ref={summaryCanvasRef}></canvas>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.render(<VelocityTracker />, document.getElementById('root'));
  </script>
</body>
</html>
